04_의존성 주입

#의존성 주입 (Dependency)

 - 한 클래스 내부에서 다른 클래스의 생성자를 가져다 사용하면 (해당 클래스의 생성자를 통해 생성하면)
   해당 클래스는 다른 클래스에게 의존하는 것이다
 - 한 프로젝트에서 다른 프로젝트를 가져다 사용하면
   해당 프로젝트는 다른 프로젝트에게 의존하는 것이다

#의존성 주입 (Dependency Injection, DI)

 - 해당 클래스가 의존하는 다른 클래스의 인스턴스를
   해당 클래스 내부에서 직접 생성하는 것이 아니라 외부에서 생성한 후 받아오는 방식
 - 의존의 대상이 되는 클래스의 인스턴스를 생성하는 작업과 
   해당 인스턴스에게 의존하는 작업을 별개로 작업으로 두어 코드간의 결합도를 낮출 수 있다.
 - 스프링은 원하는 클래스의 인스턴스를 미리 생성하여 스프링 컨텍스트에 보관하고 있다가.
   해당 인스턴스가 필요한 곳에 보관중이던 인스턴스를 알아서 주입해주는 기능을 제공한다.
 - 이 때 스프링 컨텍스트에 보관되는 인스턴스들을 Bean이라고 부른다.
 - 어떤 클래스가 Bean이 되기 위해서는 해당 클래스 위에 해당 클래스가 Bean임을 스프링에게 알리는
   어노테이션을 정의해 놓아야 한다.
 - 해당 클래스가 Bean임을 알리는 어노테이션이 적혀있는 클래스들은 스프링이 자동으로 수거하여 스프링 컨텍스트에 등록한다
 - 이처럼 미리 생성하여 스프링 컨텍스트에 등록되는 Bean들에는 자동적으로 싱글토 디자인 패턴이 적용되어있어
   메모리를 절약하게끔 만들어져 있다.
   
# 스프링의 자동 수거 대상이 되기 위한 어노테이션들

 @Component
 
  - 컨텍스트 로드시(서버 실행)시 스프링이 자동으로 수거해야 하는 모든 대상들을 컴포넌트라고 부른다
  - 용도 구분없이 해당 클래스가 컴포넌트임을 표시해놓는 어노테이션
  - 이 어노테이션을 달아놓으면 해당 클래스는 스프링 컨텍스트에 자동으로 수거되어 등록된다
  
 @Controller
 
  - 컴포넌트들 중에서 컨트롤러 역할을 하는 컴포넌트들을 컨텍스트에 등록하기 위해 사용하는 어노테이션
  - @Controller를 안달아놓으면 스프링의 수거 대상이 아니기 때문에 내부의 여러 Mapping들이 등록되지 않는다.
  
 @Repository
 
  - 컴포넌트들 중에서도 데이터 저장소에 접근하는 컴포넌트들을 등록하기 위해 사용하는 어노테이션
  - @Component와 기능적인 차이는 없고  단순히 이름을 통해 용도를 구준하기 위해 사용한다
  
 @Service
 
  - 컴포넌트 중에서도 비즈니스 로직을 수행하는 컴포넌트들을 등록하기 위해 사용하는 어노테이션
  
# 스프링 컨텍스트에 등록되어있는 의존성(Bean)을 주입하는 방법들

 1. @AutoWired
 
   (1) 의존성 주입을 원하는 필드 위에 @Autowired를 달아둔다
   (2) 스프링에 의해 해당 의존성이 자동으로 채워진다
 
 2. 생성자를 사용하는 방법
 
   (1) 해당 의존성 객체를 private final로 설정한다
   (2) 해당 의존성 객체를 생성자를 통해서 반드시 초기화 해야만 하게끔 만들어 둔다
   (3) 스프링에 의해 해당 의존성이 자동으로 채워진다
   
 3. 메서드를 사용하는 방법
   
   (1) 의존성 주입을 원하는 필드의 Setter 메서드 위에 @Autowired를 달아둔다
   (2) 스프링에 의해 해당 의존성이 자동으로 채워진다
   
# 컴포넌트가 스캔되는 범위

 - 메인 클래스 위의 @SpringBootApplication에 기본적으로 컴포넌트 스캔이 설정되어 있다
 - 기본 설정에 따르면 처음 프로젝트 생성시 설정한 기본 package 내부에 있는 모든 컴포넌트를 
   스캔하도록 설정되어 있다
 - 기본 설정대로라면 기본 package 바깥에 만드는 클래스들은 스캔의 대상이 되지않는다
 - 따로 설정을 추가하면 기본 package 바깥의 컴포넌트도 스캔하여 스프링 컨텍스트에 등록할 수 있지만
   굳이 그러지 않는다